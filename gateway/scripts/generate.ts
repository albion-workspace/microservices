/**
 * Infrastructure Generator Script
 * 
 * Generates infrastructure configurations using core-service generators.
 * Reads from configs/services.json and outputs to generated/ folder.
 * 
 * Usage:
 *   npm run generate           # Interactive mode
 *   npm run generate:nginx     # Generate nginx config only
 *   npm run generate:docker    # Generate docker-compose only
 *   npm run generate:k8s       # Generate k8s manifests only
 *   npm run generate:all       # Generate all configs
 */

import { readFile, mkdir, writeFile } from 'node:fs/promises';
import { join, dirname } from 'node:path';
import { fileURLToPath } from 'node:url';
import {
  generateMultiServiceNginxConf,
  type GatewayRoutingConfig,
  type ServiceEndpoint,
  type MultiServiceNginxConfig,
} from 'core-service';

const __dirname = dirname(fileURLToPath(import.meta.url));
const ROOT_DIR = join(__dirname, '..');
const CONFIGS_DIR = join(ROOT_DIR, 'configs');
const OUTPUT_DIR = join(ROOT_DIR, 'generated');

interface ServicesConfig {
  gateway: {
    port: number;
    defaultService: string;
    rateLimit: number;
  };
  services: Array<{
    name: string;
    host: string;
    port: number;
    database: string;
    healthPath: string;
    graphqlPath: string;
  }>;
  infrastructure: {
    mongodb: {
      mode: 'single' | 'replicaSet';
      host: string;
      port: number;
      replicaSet: string | null;
    };
    redis: {
      mode: 'single' | 'sentinel';
      host: string;
      port: number;
      sentinel: {
        hosts: Array<{ host: string; port: number }>;
        name: string;
      } | null;
    };
  };
  environments: Record<string, {
    mongoUri: string;
    redisUrl: string;
  }>;
}

async function loadConfig(): Promise<ServicesConfig> {
  const configPath = join(CONFIGS_DIR, 'services.json');
  const content = await readFile(configPath, 'utf-8');
  return JSON.parse(content);
}

function buildGatewayRoutingConfig(config: ServicesConfig): GatewayRoutingConfig {
  const services: ServiceEndpoint[] = config.services.map(svc => ({
    name: svc.name,
    host: svc.host,
    port: svc.port,
    healthPath: svc.healthPath,
    graphqlPath: svc.graphqlPath,
  }));

  return {
    strategy: 'per-service',
    port: config.gateway.port,
    defaultService: config.gateway.defaultService,
    services,
    rateLimit: config.gateway.rateLimit,
  };
}

async function generateNginx(config: ServicesConfig): Promise<void> {
  console.log('ğŸ”§ Generating nginx configuration...');
  
  const gatewayConfig = buildGatewayRoutingConfig(config);
  const nginxConfig: MultiServiceNginxConfig = {
    gateway: gatewayConfig,
    rateLimit: config.gateway.rateLimit,
    includeHttps: true,
  };

  const nginxContent = generateMultiServiceNginxConf(nginxConfig);
  
  const nginxDir = join(OUTPUT_DIR, 'nginx');
  await mkdir(nginxDir, { recursive: true });
  await writeFile(join(nginxDir, 'nginx.conf'), nginxContent);
  
  console.log('âœ… Generated: generated/nginx/nginx.conf');
}

async function generateDockerCompose(config: ServicesConfig): Promise<void> {
  console.log('ğŸ”§ Generating docker-compose configurations...');
  
  const dockerDir = join(OUTPUT_DIR, 'docker');
  await mkdir(dockerDir, { recursive: true });

  // Generate dev compose (per-service mode)
  const devCompose = generateDevCompose(config);
  await writeFile(join(dockerDir, 'docker-compose.dev.yml'), devCompose);
  console.log('âœ… Generated: generated/docker/docker-compose.dev.yml');

  // Generate prod compose (with nginx gateway)
  const prodCompose = generateProdCompose(config);
  await writeFile(join(dockerDir, 'docker-compose.prod.yml'), prodCompose);
  console.log('âœ… Generated: generated/docker/docker-compose.prod.yml');
}

function generateDevCompose(config: ServicesConfig): string {
  const namespace = 'ms';
  const serviceBlocks = config.services.map(svc => `  ${svc.host}:
    build:
      context: ../${svc.name}-service
      dockerfile: Dockerfile
    ports:
      - "${svc.port}:${svc.port}"
    environment:
      - PORT=${svc.port}
      - NODE_ENV=development
      - MONGODB_URI=mongodb://${namespace}-mongo:27017/${svc.database}
      - REDIS_URL=redis://${namespace}-redis:6379
    depends_on:
      - ${namespace}-mongo
      - ${namespace}-redis
    networks:
      - ${namespace}-network
    volumes:
      - ../${svc.name}-service/src:/app/src:ro`).join('\n\n');

  return `# Development Docker Compose - Per-Service Mode
# Generated by gateway/scripts/generate.ts
# Each service runs on its own port

version: '3.8'

services:
${serviceBlocks}

  ${namespace}-mongo:
    image: mongo:7
    ports:
      - "27017:27017"
    volumes:
      - ${namespace}-mongo-data:/data/db
    networks:
      - ${namespace}-network

  ${namespace}-redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    networks:
      - ${namespace}-network

networks:
  ${namespace}-network:
    driver: bridge

volumes:
  ${namespace}-mongo-data:
`;
}

function generateProdCompose(config: ServicesConfig): string {
  const namespace = 'ms';
  const gatewayPort = config.gateway.port;

  const serviceBlocks = config.services.map(svc => `  ${svc.host}:
    image: ${svc.name}-service:latest
    environment:
      - PORT=${svc.port}
      - NODE_ENV=production
      - MONGODB_URI=mongodb://${namespace}-mongo:27017/${svc.database}
      - REDIS_URL=redis://${namespace}-redis:6379
    depends_on:
      - ${namespace}-mongo
      - ${namespace}-redis
    networks:
      - ${namespace}-network
    deploy:
      replicas: 2
      resources:
        limits:
          cpus: '0.5'
          memory: 512M`).join('\n\n');

  return `# Production Docker Compose - With Nginx Gateway
# Generated by gateway/scripts/generate.ts
# Single entry point on port ${gatewayPort}, routes by X-Target-Service header

version: '3.8'

services:
  gateway:
    image: nginx:alpine
    ports:
      - "${gatewayPort}:${gatewayPort}"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
${config.services.map(s => `      - ${s.host}`).join('\n')}
    networks:
      - ${namespace}-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:${gatewayPort}/health"]
      interval: 30s
      timeout: 10s
      retries: 3

${serviceBlocks}

  ${namespace}-mongo:
    image: mongo:7
    volumes:
      - ${namespace}-mongo-data:/data/db
    networks:
      - ${namespace}-network

  ${namespace}-redis:
    image: redis:7-alpine
    networks:
      - ${namespace}-network

networks:
  ${namespace}-network:
    driver: bridge

volumes:
  ${namespace}-mongo-data:
`;
}

async function generateK8s(config: ServicesConfig): Promise<void> {
  console.log('ğŸ”§ Generating Kubernetes manifests...');
  
  const k8sDir = join(OUTPUT_DIR, 'k8s');
  await mkdir(k8sDir, { recursive: true });

  // Namespace
  const namespace = generateK8sNamespace();
  await writeFile(join(k8sDir, '00-namespace.yaml'), namespace);

  // ConfigMap
  const configMap = generateK8sConfigMap(config);
  await writeFile(join(k8sDir, '01-configmap.yaml'), configMap);

  // Services deployments
  for (const svc of config.services) {
    const deployment = generateK8sDeployment(svc, config);
    await writeFile(join(k8sDir, `10-${svc.name}-deployment.yaml`), deployment);
  }

  // Ingress
  const ingress = generateK8sIngress(config);
  await writeFile(join(k8sDir, '20-ingress.yaml'), ingress);

  console.log('âœ… Generated: generated/k8s/*.yaml');
}

function generateK8sNamespace(): string {
  return `apiVersion: v1
kind: Namespace
metadata:
  name: microservices
`;
}

function generateK8sConfigMap(config: ServicesConfig): string {
  return `apiVersion: v1
kind: ConfigMap
metadata:
  name: services-config
  namespace: microservices
data:
  GATEWAY_PORT: "${config.gateway.port}"
  DEFAULT_SERVICE: "${config.gateway.defaultService}"
${config.services.map(s => `  ${s.name.toUpperCase()}_PORT: "${s.port}"`).join('\n')}
`;
}

function generateK8sDeployment(svc: ServicesConfig['services'][0], config: ServicesConfig): string {
  return `apiVersion: apps/v1
kind: Deployment
metadata:
  name: ${svc.name}-service
  namespace: microservices
spec:
  replicas: 2
  selector:
    matchLabels:
      app: ${svc.name}-service
  template:
    metadata:
      labels:
        app: ${svc.name}-service
    spec:
      containers:
      - name: ${svc.name}-service
        image: ${svc.name}-service:latest
        ports:
        - containerPort: ${svc.port}
        env:
        - name: PORT
          value: "${svc.port}"
        - name: NODE_ENV
          value: "production"
        - name: MONGODB_URI
          valueFrom:
            secretKeyRef:
              name: db-secrets
              key: mongodb-uri
        - name: REDIS_URL
          valueFrom:
            secretKeyRef:
              name: db-secrets
              key: redis-url
        livenessProbe:
          httpGet:
            path: ${svc.healthPath}
            port: ${svc.port}
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: ${svc.healthPath}
            port: ${svc.port}
          initialDelaySeconds: 5
          periodSeconds: 5
        resources:
          requests:
            cpu: "250m"
            memory: "256Mi"
          limits:
            cpu: "500m"
            memory: "512Mi"
---
apiVersion: v1
kind: Service
metadata:
  name: ${svc.name}-service
  namespace: microservices
spec:
  selector:
    app: ${svc.name}-service
  ports:
  - port: ${svc.port}
    targetPort: ${svc.port}
`;
}

function generateK8sIngress(config: ServicesConfig): string {
  return `apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: api-gateway
  namespace: microservices
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /graphql
    nginx.ingress.kubernetes.io/configuration-snippet: |
      # Route based on X-Target-Service header
      set $target_service $http_x_target_service;
      if ($target_service = "") {
        set $target_service "${config.gateway.defaultService}";
      }
spec:
  ingressClassName: nginx
  rules:
  - http:
      paths:
      - path: /graphql
        pathType: Prefix
        backend:
          service:
            name: ${config.gateway.defaultService}-service
            port:
              number: ${config.services.find(s => s.name === config.gateway.defaultService)?.port || 9001}
`;
}

async function main(): Promise<void> {
  const args = process.argv.slice(2);
  
  console.log('');
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log(' Gateway Infrastructure Generator');
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('');

  const config = await loadConfig();
  console.log(`ğŸ“‹ Loaded config: ${config.services.length} services`);
  console.log(`   Gateway port: ${config.gateway.port}`);
  console.log(`   Default service: ${config.gateway.defaultService}`);
  console.log('');

  const generateAll = args.includes('--all') || args.length === 0;
  
  if (generateAll || args.includes('--nginx')) {
    await generateNginx(config);
  }
  
  if (generateAll || args.includes('--docker')) {
    await generateDockerCompose(config);
  }
  
  if (generateAll || args.includes('--k8s')) {
    await generateK8s(config);
  }

  console.log('');
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log(' Generation Complete!');
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('');
  console.log('Output directory: gateway/generated/');
  console.log('');
}

main().catch(console.error);
