/**
 * Generic Microservice Benchmark
 * 
 * Works with any GraphQL microservice in the system.
 * 
 * Usage:
 *   npx tsx benchmark.ts                          # Test all discovered services
 *   npx tsx benchmark.ts --service bonus          # Test specific service
 *   npx tsx benchmark.ts --url http://localhost:9003/graphql
 * 
 * Environment Variables:
 *   BONUS_URL, PAYMENT_URL, RETAIL_URL - Service URLs
 */

import { createHmac } from 'node:crypto';
import { createSystemToken, initializeConfig } from './config/users.js';
import { 
  loadScriptConfig,
  BONUS_SERVICE_URL,
  PAYMENT_SERVICE_URL,
} from './config/scripts.js';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// JWT Token Generation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const SERVICE_SECRETS: Record<string, string> = {
  bonus: process.env.BONUS_JWT_SECRET || 'bonus-service-secret-change-in-production',
  payment: process.env.PAYMENT_JWT_SECRET || 'payment-gateway-secret-change-in-production',
  retail: process.env.RETAIL_JWT_SECRET || 'retail-app-secret-change-in-production',
};

function generateAdminToken(secret?: string): string {
  // Use centralized token generation (secret is handled internally)
  return createSystemToken('8h', true); // true = include Bearer prefix
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Service Registry
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

interface ServiceConfig {
  name: string;
  url: string;
  healthQuery: string;
  listQuery: string;
  createMutation?: {
    query: string;
    variables: () => Record<string, unknown>;
  };
  description: string;
}

// Initialize service URLs dynamically
let SERVICES: Record<string, ServiceConfig> = {};

async function initializeServices() {
  await initializeConfig();
  await loadScriptConfig(); // This populates BONUS_SERVICE_URL, PAYMENT_SERVICE_URL, etc.
  
  SERVICES = {
    bonus: {
      name: 'bonus-service',
      url: BONUS_SERVICE_URL,
      healthQuery: '{ health { status } }',
      listQuery: '{ bonusTemplates { nodes { id code type } totalCount } }',
      createMutation: {
        query: `mutation CreateTemplate($input: CreateBonusTemplateInput!) {
          createBonusTemplate(input: $input) { success bonusTemplate { id } executionTimeMs }
        }`,
        variables: () => ({
          input: {
            code: `BENCH-${Date.now()}-${Math.random().toString(36).slice(2)}`,
            name: 'Benchmark Test Bonus',
            description: 'Auto-generated by benchmark',
            type: 'activity',
            domain: 'universal',
            currency: 'USD',
            valueType: 'fixed',
            value: 10,
            turnoverMultiplier: 1,
            durationDays: 30,
            isActive: false,
          },
        }),
      },
      description: 'Bonus service - templates, user bonuses, turnover tracking',
    },
    payment: {
      name: 'payment-gateway',
      url: PAYMENT_SERVICE_URL,
      healthQuery: '{ health { status } }',
      listQuery: '{ wallets { nodes { id userId currency balance } totalCount } }',
      createMutation: {
        query: `mutation CreateWallet($input: CreateWalletInput!) {
          createWallet(input: $input) { success wallet { id } executionTimeMs }
        }`,
        variables: () => ({
          input: {
            userId: `bench-${Date.now()}-${Math.random().toString(36).slice(2)}`,
            currency: 'USD',
          },
        }),
      },
      description: 'Payment gateway - wallets, deposits, withdrawals',
    },
    retail: {
      name: 'retail-app',
      url: process.env.RETAIL_URL || 'http://localhost:3000/graphql', // Retail not in config yet
      healthQuery: '{ health { status } }',
      listQuery: '{ terminals { nodes { id name } totalCount } }',
      createMutation: {
        query: `mutation CreateTerminal($input: CreateTerminalInput!) {
          createTerminal(input: $input) { success terminal { id } executionTimeMs }
        }`,
        variables: () => ({
          input: {
            name: `BENCH-${Date.now()}`,
            branchId: '999',
            securityCode: `BENCH-${Date.now()}-${Math.random().toString(36).slice(2)}`,
          },
        }),
      },
      description: 'Retail app - terminals, branches, transactions',
    },
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Configuration
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const BENCHMARK_CONFIG = {
  defaultIterations: 100,
  warmupIterations: 5,
  createIterations: 50,
  concurrentWorkers: 10,
  concurrentDurationMs: 5000,
  percentileTarget: 0.95,
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Types
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

interface BenchmarkResult {
  name: string;
  iterations: number;
  totalMs: number;
  avgMs: number;
  minMs: number;
  maxMs: number;
  p95Ms: number;
  rps: number;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HTTP Client
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function fetchDevToken(url: string): Promise<string | null> {
  try {
    // Try to get the dev token from the service logs via GraphQL introspection
    // Most services expose a health endpoint that works without auth
    const res = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ query: '{ health { status } }' }),
    });
    
    // If health works without auth, try to get from a mutation that returns a token
    if (res.ok) {
      // Return a placeholder - we'll generate tokens dynamically
      return null;
    }
    return null;
  } catch {
    return null;
  }
}

async function graphql(
  url: string,
  query: string,
  variables?: Record<string, unknown>,
  token?: string
): Promise<{ data?: unknown; errors?: Array<{ message: string }> }> {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
  };
  
  if (token) {
    headers['Authorization'] = token.startsWith('Bearer ') ? token : `Bearer ${token}`;
  }
  
  const res = await fetch(url, {
    method: 'POST',
    headers,
    body: JSON.stringify({ query, variables }),
  });
  
  return res.json();
}

async function runQuery(
  url: string,
  query: string,
  variables?: Record<string, unknown>,
  token?: string
): Promise<number> {
  const start = performance.now();
  await graphql(url, query, variables, token);
  return performance.now() - start;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Service Discovery
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function discoverServices(): Promise<Array<{ config: ServiceConfig; token: string }>> {
  const discovered: Array<{ config: ServiceConfig; token: string }> = [];
  
  console.log('ğŸ” Discovering available services...\n');
  
  for (const [key, config] of Object.entries(SERVICES)) {
    try {
      // Try health check without auth (health is usually public)
      const healthRes = await graphql(config.url, config.healthQuery);
      
      if (healthRes.data) {
        // Generate a token using the service's JWT secret
        const secret = SERVICE_SECRETS[key];
        let token = '';
        
        if (secret) {
          token = generateAdminToken(secret);
          console.log(`  âœ… ${config.name} at ${config.url} (auto-generated token)`);
        } else {
          // Try without token (some queries might be public)
          const testRes = await graphql(config.url, config.listQuery);
          if (testRes.errors) {
            console.log(`  âš ï¸  ${config.name}: No secret configured (set ${key.toUpperCase()}_JWT_SECRET)`);
            continue;
          }
          console.log(`  âœ… ${config.name} at ${config.url} (no auth required)`);
        }
        
        discovered.push({ config, token });
      }
    } catch (err) {
      console.log(`  âŒ ${config.name}: Not available (${(err as Error).message})`);
    }
  }
  
  return discovered;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Benchmarking Functions
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function benchmark(
  name: string,
  url: string,
  query: string,
  iterations: number,
  token?: string,
  variables?: Record<string, unknown>
): Promise<BenchmarkResult> {
  const times: number[] = [];
  
  // Warmup
  for (let i = 0; i < BENCHMARK_CONFIG.warmupIterations; i++) {
    await runQuery(url, query, variables, token);
  }
  
  // Actual benchmark
  for (let i = 0; i < iterations; i++) {
    times.push(await runQuery(url, query, variables, token));
  }
  
  times.sort((a, b) => a - b);
  const totalMs = times.reduce((a, b) => a + b, 0);
  
  return {
    name,
    iterations,
    totalMs: Math.round(totalMs),
    avgMs: Math.round(totalMs / iterations),
    minMs: Math.round(times[0]),
    maxMs: Math.round(times[times.length - 1]),
    p95Ms: Math.round(times[Math.floor(iterations * BENCHMARK_CONFIG.percentileTarget)]),
    rps: Math.round(iterations / (totalMs / 1000)),
  };
}

async function concurrentBenchmark(
  name: string,
  url: string,
  query: string,
  concurrency: number,
  duration: number,
  token?: string,
  variablesFn?: () => Record<string, unknown>
): Promise<BenchmarkResult> {
  const times: number[] = [];
  const start = Date.now();
  let running = true;
  
  setTimeout(() => { running = false; }, duration);
  
  const workers = Array(concurrency).fill(null).map(async () => {
    while (running) {
      const variables = variablesFn?.();
      times.push(await runQuery(url, query, variables, token));
    }
  });
  
  await Promise.all(workers);
  
  if (times.length === 0) {
    return {
      name,
      iterations: 0,
      totalMs: 0,
      avgMs: 0,
      minMs: 0,
      maxMs: 0,
      p95Ms: 0,
      rps: 0,
    };
  }
  
  times.sort((a, b) => a - b);
  const totalMs = times.reduce((a, b) => a + b, 0);
  
  return {
    name,
    iterations: times.length,
    totalMs: Math.round(totalMs),
    avgMs: Math.round(totalMs / times.length),
    minMs: Math.round(times[0]),
    maxMs: Math.round(times[times.length - 1]),
    p95Ms: Math.round(times[Math.floor(times.length * BENCHMARK_CONFIG.percentileTarget)]),
    rps: Math.round(times.length / (duration / 1000)),
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Output Formatting
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function printResult(result: BenchmarkResult) {
  console.log(`
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ${result.name.padEnd(57)} â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Iterations: ${String(result.iterations).padEnd(45)} â”‚
â”‚ Total Time: ${String(result.totalMs + 'ms').padEnd(45)} â”‚
â”‚ Avg:        ${String(result.avgMs + 'ms').padEnd(45)} â”‚
â”‚ Min:        ${String(result.minMs + 'ms').padEnd(45)} â”‚
â”‚ Max:        ${String(result.maxMs + 'ms').padEnd(45)} â”‚
â”‚ P95:        ${String(result.p95Ms + 'ms').padEnd(45)} â”‚
â”‚ RPS:        ${String(result.rps + ' req/sec').padEnd(45)} â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜`);
}

function printSummary(results: Array<{ service: string; results: BenchmarkResult[] }>) {
  console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                           BENCHMARK SUMMARY                                  â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ Service / Test                    â•‘ Avg (ms)  â•‘ P95 (ms)  â•‘ RPS             â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£`);
  
  for (const { service, results: svcResults } of results) {
    console.log(`â•‘ ${service.padEnd(33)} â•‘           â•‘           â•‘                 â•‘`);
    for (const r of svcResults) {
      const name = `  ${r.name.slice(0, 31)}`;
      console.log(`â•‘ ${name.padEnd(33)} â•‘ ${String(r.avgMs).padStart(9)} â•‘ ${String(r.p95Ms).padStart(9)} â•‘ ${String(r.rps).padStart(15)} â•‘`);
    }
  }
  
  console.log(`â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Main
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function benchmarkService(
  config: ServiceConfig,
  token: string
): Promise<BenchmarkResult[]> {
  const results: BenchmarkResult[] = [];
  
  console.log(`\n${'â•'.repeat(70)}`);
  console.log(`ğŸ“Š Benchmarking: ${config.name}`);
  console.log(`   ${config.description}`);
  console.log(`   URL: ${config.url}`);
  console.log(`${'â•'.repeat(70)}`);
  
  // Test 1: Health check (baseline)
  const health = await benchmark(
    'Health Check',
    config.url,
    config.healthQuery,
    BENCHMARK_CONFIG.defaultIterations,
    token
  );
  printResult(health);
  results.push(health);
  
  // Test 2: List query
  const list = await benchmark(
    'List Query',
    config.url,
    config.listQuery,
    BENCHMARK_CONFIG.defaultIterations,
    token
  );
  printResult(list);
  results.push(list);
  
  // Test 3: Create mutation (if available)
  if (config.createMutation) {
    const createTimes: number[] = [];
    const createIters = BENCHMARK_CONFIG.createIterations;
    
    for (let i = 0; i < createIters; i++) {
      const variables = config.createMutation.variables();
      createTimes.push(await runQuery(config.url, config.createMutation.query, variables, token));
    }
    
    createTimes.sort((a, b) => a - b);
    const createResult: BenchmarkResult = {
      name: 'Create Mutation',
      iterations: createIters,
      totalMs: Math.round(createTimes.reduce((a, b) => a + b, 0)),
      avgMs: Math.round(createTimes.reduce((a, b) => a + b, 0) / createIters),
      minMs: Math.round(createTimes[0]),
      maxMs: Math.round(createTimes[createTimes.length - 1]),
      p95Ms: Math.round(createTimes[Math.floor(createIters * BENCHMARK_CONFIG.percentileTarget)]),
      rps: Math.round(createIters / (createTimes.reduce((a, b) => a + b, 0) / 1000)),
    };
    printResult(createResult);
    results.push(createResult);
  }
  
  // Test 4: Concurrent load
  const workers = BENCHMARK_CONFIG.concurrentWorkers;
  const duration = BENCHMARK_CONFIG.concurrentDurationMs;
  console.log(`\nâ³ Running concurrent test (${workers} workers, ${duration / 1000}s)...`);
  
  const concurrent = await concurrentBenchmark(
    `Concurrent (${workers}w)`,
    config.url,
    config.listQuery,
    workers,
    duration,
    token
  );
  printResult(concurrent);
  results.push(concurrent);
  
  return results;
}

async function main() {
  // Initialize services from config
  await initializeServices();
  console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘             GENERIC MICROSERVICE BENCHMARK                                 â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Tests all available microservices with:                                   â•‘
â•‘  â€¢ Health check (baseline latency)                                         â•‘
â•‘  â€¢ List queries (read performance)                                         â•‘
â•‘  â€¢ Create mutations (write performance with sagas)                         â•‘
â•‘  â€¢ Concurrent load (throughput under load)                                 â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`);
  
  // Parse command line args
  const args = process.argv.slice(2);
  const serviceArg = args.find(a => a.startsWith('--service='))?.split('=')[1] 
    || (args.includes('--service') ? args[args.indexOf('--service') + 1] : null);
  const urlArg = args.find(a => a.startsWith('--url='))?.split('=')[1]
    || (args.includes('--url') ? args[args.indexOf('--url') + 1] : null);
  
  let servicesToTest: Array<{ config: ServiceConfig; token: string }> = [];
  
  if (urlArg) {
    // Custom URL - use generic config
    servicesToTest = [{
      config: {
        name: 'Custom Service',
        url: urlArg,
        healthQuery: '{ health { status } }',
        listQuery: '{ __schema { types { name } } }', // Fallback to introspection
        description: 'Custom service at ' + urlArg,
      },
      token: process.env.AUTH_TOKEN || '',
    }];
  } else if (serviceArg && SERVICES[serviceArg]) {
    // Specific service
    const config = SERVICES[serviceArg];
    const secret = SERVICE_SECRETS[serviceArg];
    const token = secret ? generateAdminToken(secret) : '';
    servicesToTest = [{ config, token }];
    console.log(`\nğŸ“Œ Testing specific service: ${serviceArg} (auto-generated token)`);
  } else {
    // Auto-discover all services
    servicesToTest = await discoverServices();
  }
  
  if (servicesToTest.length === 0) {
    console.log('\nâŒ No services available. Make sure services are running.');
    console.log('   Start services with: npm start (in each service directory)');
    process.exit(1);
  }
  
  // Run benchmarks
  const allResults: Array<{ service: string; results: BenchmarkResult[] }> = [];
  
  for (const { config, token } of servicesToTest) {
    const results = await benchmarkService(config, token);
    allResults.push({ service: config.name, results });
  }
  
  // Print summary
  printSummary(allResults);
}

main().catch(console.error);
